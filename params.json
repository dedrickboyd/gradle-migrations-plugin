{"name":"Gradle-migrations-plugin","tagline":"Mybatis migrations plugin to use with Gradle","body":"Gradle Migrations Plugin [![Build Status](https://travis-ci.org/marceloemanoel/gradle-migrations-plugin.png?branch=master)](https://travis-ci.org/marceloemanoel/gradle-migrations-plugin?branch=master)\r\n=============================\r\n\r\nProvide gradle build integration with [mybatis migrations](https://code.google.com/p/mybatis/wiki/Migration). \r\nThe plugin adds a group of tasks named **Migrations** composed by:\r\n\r\n<table width=\"100%\">\r\n  <thead>\r\n    <th>\r\n      Task\r\n    </th>\r\n    <th>\r\n      Description\r\n    </th>\r\n    <th>\r\n      Parameters\r\n    </th>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><a href=\"#migrateinit\">migrateInit</a></td>\r\n      <td>Create migrations repository structure</td>\r\n      <td>-</td>\r\n    </tr>\r\n    <tr>\r\n      <td><a href=\"#migratebootstrap\">migrateBootstrap</a></td>\r\n      <td>Use an existing database structure as an starting point for migrations</td>\r\n      <td>-</td>\r\n    </tr>\r\n    <tr>\r\n      <td><a href=\"#migratestatus\">migrateStatus</a></td>\r\n      <td>Shows current database status</td>\r\n      <td>-</td>\r\n    </tr>\r\n    <tr>\r\n      <td><a href=\"#migratenew\">migrateNew</a></td>\r\n      <td>Create a new migration file.</td>\r\n      <td>description, template</td>\r\n    </tr>\r\n    <tr>\r\n      <td><a href=\"#migrateup-and-migratedown\">migrateUp</a></td>\r\n      <td>Apply any pending migration following creation order.</td>\r\n      <td>steps</td>\r\n    </tr>\r\n    <tr>\r\n      <td><a href=\"#migrateup-and-migratedown\">migrateDown</a></td>\r\n      <td>Rewinds the database to a previous stage.</td>\r\n      <td>steps</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\nInstall\r\n=======\r\n\r\nJust put the following code snippet in your build.gradle file.\r\n\r\n```groovy\r\nbuildscript {\r\n  repositories {\r\n    mavenCentral()\r\n  }\r\n  dependencies {\r\n    classpath \"com.github.marceloemanoel:gradle-migrations:0.2.1\"\r\n  }\r\n}\r\n\r\napply plugin: \"migrations\"\r\n```\r\n\r\nConfigurations\r\n==============\r\n\r\nThe only **required** configuration is made on your scripts dependencies section.\r\nThe plugin add a configuration scope known as `migrationsDriver`. As its name states,\r\nthis configuration scope should contain all JDBC drivers that will be used by your migrations.\r\n\r\nTo use the migrations with a mysql database for example, one should instruct the build as following:\r\n\r\n```groovy\r\ndependencies {\r\n  migrationsDriver 'mysql:mysql-connector-java:5+'\r\n}\r\n```\r\n\r\nThis will ensure that the last mysql connector will be downloaded when you first run any migration task,\r\nit will be cached by gradle and on later calls it will be used from the local repository.\r\n\r\nCustomization\r\n=============\r\n\r\nFollowing the rule of convention over configuration the plugin adds a configuration closure to your build.\r\nIf all default values are good for you, you're ready to go. But if you need to change anything, you'll see that \r\nit is an easy task. You only need to write the following on your `build.gradle` file: \r\n\r\n```groovy\r\nmigrations {\r\n   baseDir = \"anotherDirectory\"\r\n   environment = \"test\"\r\n   force = true\r\n}\r\n```\r\n\r\nAll values are optional. The following table presents the default values of each property:\r\n\r\n<table width=\"100%\">\r\n  <thead>\r\n    <th>Property</th>\r\n    <th>Description</th>\r\n    <th>Default Value</th>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td>baseDir</td>\r\n      <td>Defines the base directory containing the migrations</td>\r\n      <td>migrations</td>\r\n    </tr>\r\n    <tr>\r\n      <td>environment</td>\r\n      <td>Defines the database environment used by the tasks</td>\r\n      <td>development</td>\r\n    </tr>\r\n    <tr>\r\n      <td>force</td>\r\n      <td>Forces the execution of the tasks</td>\r\n      <td>false</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\nAvailable Tasks\r\n===============\r\n\r\nmigrateInit\r\n-----------\r\nThe init command initializes a new repository’ of migration scripts. You’ll run init once to create the\r\nworkspace in which everything you need to manage database change will be placed. Running this\r\ncommand will create the directory specified by the `baseDir` property (which is the directory \"migrations\"\r\nby default). In case it already exists the command will fail unless the property `force` is true. \r\n\r\nWhen the command is completed, the directory will contain the following sub-directories:\r\n\r\n> environments\r\n\r\nIn the environments folder you will find .properties files that represent your database instances. By\r\ndefault a `development.properties` file is created for you to configure your development time database\r\nproperties. You can also create `test.properties`, `production.properties` or even a `anything.properties` file. \r\nThe environment can be specified when running a migration by using the `environment` property \r\nwithout the path or \".properties\" part (the default value is \"development\").\r\n\r\n> scripts\r\n\r\nThis directory contains your migration SQL files. These are the files that contain your DDL to both\r\nupgrade and downgrade your database structure. By default, the directory will contain the script to\r\ncreate the changelog table, plus one empty example migration script. To create a new migration script,\r\nuse the [migrateNew](#migratenew) command. To run all pending migrations in order, use the [migrateUp](#migrateup) \r\ncommand. To undo the last migration applied, use the [migrateDown](#migratedown) command etc.\r\n\r\nmigrateBootstrap\r\n----------------\r\nThe bootstrap command enables the starting point for migrations if you’re working from an existing database.\r\nThere’s no point in trying to rewind time and shoehorn your existing database into a series of migration scripts. \r\nIt’s more practical to just accept the current state of your database schema and identify this as the starting point.\r\nIn the scripts directory you’ll find a file named `bootstrap.sql`. You can put your existing DDL script in this file. \r\nIf you don’t have a DDL script, you can export your existing database schema and put it in the bootstrap file. \r\nYou’ll want to clean it up so that it doesn’t contain anything specific to any one environment, but otherwise almost \r\nany script should work. Watch out for DDL that contains conditional elements or branching logic that could generate \r\nmultiple schemas. While this is sometimes necessary, it’s a really good idea to try to eliminate this aspect of your\r\ndatabase schema (put such conditional and branching logic in your code or stored procedures instead).\r\nIf you have multiple DDL files, you’ll have to merge them into the single bootstrap file. But worry not,\r\nit’s the last time you’ll ever modify it. \r\n\r\nIn order to run, the [migrateBootstrap command](#migratebootstrap) need the JDBC driver of your database.\r\nThe plugin add the configuration `migrationsDriver` to your project. More information [here](#configurations).\r\n\r\nmigrateStatus\r\n-------------\r\nThe status command will report the current state of the database. \r\n\r\n<pre>\r\n:migrateStatus\r\nID             Applied At          Description\r\n================================================================================\r\n20130314124532    ...pending...    create changelog\r\n20130314124533    ...pending...    first migration\r\n</pre>\r\n\r\nmigrateNew\r\n----------\r\nThis task enable the creation of new migrations. Every migration script file should have a .sql extension \r\nand have both sections **DO** and **UNDO**. As soon you init the migrations repository two files are \r\ncreated for you, the changelog migration and the first migration. The changelog migration contains \r\nthe following code:\r\n\r\n```sql\r\n--// Create Changelog\r\n\r\n-- Default DDL for changelog table that will keep\r\n-- a record of the migrations that have been run.\r\n\r\n-- You can modify this to suit your database before\r\n-- running your first migration.\r\n\r\n-- Be sure that ID and DESCRIPTION fields exist in\r\n-- BigInteger and String compatible fields respectively.\r\n\r\nCREATE TABLE ${changelog} (\r\nID NUMERIC(20,0) NOT NULL,\r\nAPPLIED_AT VARCHAR(25) NOT NULL,\r\nDESCRIPTION VARCHAR(255) NOT NULL\r\n);\r\n\r\nALTER TABLE ${changelog}\r\nADD CONSTRAINT PK_${changelog}\r\nPRIMARY KEY (id);\r\n\r\n--//@UNDO\r\n\r\nDROP TABLE ${changelog};\r\n```\r\n\r\nThis file is composed of three sections:\r\n\r\n* Description: Delimited by `--//`, used to describe the migration in the database.\r\n\r\n```sql\r\n--// Create Changelog\r\n```\r\n\r\n* DO: Everything after the description, used to push forward the database\r\n\r\n```sql\r\n\r\n-- Default DDL for changelog table that will keep\r\n-- a record of the migrations that have been run.\r\n\r\n-- You can modify this to suit your database before\r\n-- running your first migration.\r\n\r\n-- Be sure that ID and DESCRIPTION fields exist in\r\n-- BigInteger and String compatible fields respectively.\r\n\r\nCREATE TABLE ${changelog} (\r\nID NUMERIC(20,0) NOT NULL,\r\nAPPLIED_AT VARCHAR(25) NOT NULL,\r\nDESCRIPTION VARCHAR(255) NOT NULL\r\n);\r\n\r\nALTER TABLE ${changelog}\r\nADD CONSTRAINT PK_${changelog}\r\nPRIMARY KEY (id);\r\n\r\n```\r\n\r\n* UNDO: Everything after the `--//@UNDO` line, used to push backward the database\r\n\r\n```sql\r\n\r\nDROP TABLE ${changelog};\r\n```\r\n\r\nThe migrateNew task needs **one** parameter to work as expected, the description of what this migration \r\nwill do to your database. It is used like this:\r\n\r\n> gradle migrateNew -Pdescription=\"This is a sample migration\"\r\n\r\nThis parameter can be abreviated as simple as this:\r\n\r\n> gradle migrateNew -Pd=\"This is a sample migration\"\r\n\r\nmigrateUp and migrateDown\r\n-------------------------\r\n\r\nTheses tasks enable the evolving and devolving of your database. They use the script files inside the scripts directory.\r\n\r\nThe task `migrateUp` uses the **DO section** of the migration scripts to push forward your database and \r\nthe `migrateDown`, in its turn, uses its **UNDO section** to push backward your database.\r\n\r\nBoth tasks have a parameter named `steps`. By default its value is **1** for `migrateDown` since you probably want to \r\nrollback only the last migration. For `migrateUp` the default value is `Integer.MAX_VALUE` this is because you probanly\r\nwant to execute all upwards pending migrations. The parameter is easily applied through the command line as following:\r\n\r\n> gradle migrateUp -Psteps=2\r\n\r\nor\r\n\r\n> gradle migrateDown -Psteps=3\r\n\r\nIt is possible to abreviate it like this:\r\n\r\n> gradle migrateUp -Ps=2\r\n\r\nor \r\n\r\n> gradle migrateDown -Ps=3\r\n\r\n\r\nLicense\r\n=======\r\n\r\nCopyright 2012 Marcelo Emanoel B. Diniz\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\nDevelopers\r\n==========\r\n\r\n* [Marcelo Emanoel B. Diniz](http://github.com/marceloemanoel)\r\n* [Mircea Pop](http://github.com/mircea-pop)\r\n\r\nContributions\r\n=============\r\n\r\nJust fork the project and send a pull request :D\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}